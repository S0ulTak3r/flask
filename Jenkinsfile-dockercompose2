@Library('FunctionsLibrary') _

pipeline 
{
    agent any

    environment 
    {
        // Define environment variables that will be used throughout the pipeline
        SSHKEYLOCATION = "${params.SSHKEYLOCATION}"
        DOCKERFLASKIMAGE = "${params.DOCKERFLASKNAME}"
        DOCKERDBIMAGE = "${params.DOCKERDBNAME}"
        ANSIBLEFOLDER = "${params.ANSIBLEFOLDER}"
        GITURL = "${params.GITURL}"
        REQLOCATION = "${params.REQLOCATION}"
        GIT_SSH_COMMAND = "ssh -o StrictHostKeyChecking=no"
        WINDOWSIP= "${params.WINDOWSIP}"
        GITROOTFOLDER = "${params.GITROOTFOLDER}"
        GCSBUCKETNAME = "${params.GCSBUCKETNAME}"
        GCSHELMFOLDER = "${params.GCSHELMFOLDER}"
        INSTALLLOCALPLAYBOOK = "${params.INSTALLLOCALPLAYBOOK}"
        CLUSTERNAME = "${params.CLUSTERNAME}"
        CLUSTERZONE = "${params.CLUSTERZONE}"
        GOOGLEPROJECTNAME = "${params.GOOGLEPROJECTNAME}"
        TERRAFORMFOLDERNAME = "${params.TERRAFORMFOLDERNAME}"
        FLASKBUILDFOLDER = "${params.FLASKBUILDFOLDER}"
        DBBUILDFOLDER = "${params.DBBUILDFOLDER}"
        TESTCONTEXT = "${params.TESTCONTEXT}"
        TESTHELMRELEASE = "${params.TESTHELMRELEASE}"
        PRODCONTEXT = "${params.PRODCONTEXT}"
        PRODHELMRELEASE = "${params.PRODHELMRELEASE}"
        HELMPACKAGENAME = "${params.HELMPACKAGENAME}"
    }

    triggers 
    {
        pollSCM('*/1 * * * *')
    }
    
    stages 
    {
        
        stage('Changes Check') 
        {
            steps 
            {
                script 
                {
                    pipelinefunctions.checkChanges()
                }
            }
        }

        stage('Cleanup') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    pipelinefunctions.cleanupWorkspace()
                    sh "sudo docker image prune --force"
                    sh "sudo docker container prune --force"
                    dockerfunctions.deleteImageVersion(env.DOCKERFLASKIMAGE)
                    dockerfunctions.deleteImageVersion(env.DOCKERDBIMAGE)
                }
            }
        }
        
        stage('Clone') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    gitfunctions.clonegit(env.GITURL)
                    sh "aws s3 cp s3://daniel-sela/unity-build.zip unity-build.zip"
                    sh "unzip unity-build.zip -d ./flask/flask-app/Static/"
                }
            }
        }
        
        stage('Install Dependencies') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    ansiblefunctions.installDependenciesSystemLvl(env.ANSIBLEFOLDER,env.INSTALLLOCALPLAYBOOK)
                }
            }
        }

        stage('Docker Login')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    dockerfunctions.loginDockerHub()
                }
            }
        }
        
        // Build Docker images for the Flask application and the database, and push them to DockerHub
        stage('Parallel Docker Build and Push') 
        {
            when 
            {
                // Only run this stage if there have been changes to the repository
                expression { return shouldRunStage() }
            }
            steps 
            {
                script 
                {
                    // Build Docker images for the Flask application and the database in parallel to save time
                    // If there are relevant changes detected in the source code, the images will also be pushed to DockerHub
                    parallel(
                        "Build-create dockerFlask image and push": {
                            dockerfunctions.BuildCheckAndPushV2(env.DOCKERFLASKIMAGE, "${env.GITROOTFOLDER}/${env.FLASKBUILDFOLDER}/")
                        },
                        "Build-create dockerDB image and push": {
                            dockerfunctions.BuildCheckAndPush(env.DOCKERDBIMAGE, "${env.GITROOTFOLDER}/${env.DBBUILDFOLDER}/")
                        }
                    )
                }
            }
        }

        stage('Get Test+Prod Instance Details + install docker')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                //pulls IP of test instance by automatical means
                script 
                {
                    awsfunctions.GetInstanceDetails()
                }
            }
        }

        stage("install test+prod docker")
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    ansiblefunctions.installDockerRemote(env.ANSIBLEFOLDER,"InstallAllComponents.yml")
                }
            }
        }

        stage('fetch docker-compose file to test+prod')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    scpfunctions.TransferFile(env.publicTestIp,"./flask/docker-compose.yml",env.SSHKEYLOCATION)
                    scpfunctions.TransferFile(env.publicTestIp,"./flask/prometheusconfig.yml",env.SSHKEYLOCATION)
                    scpfunctions.TransferFile(env.publicProdIp,"./flask/docker-compose.yml",env.SSHKEYLOCATION)
                    scpfunctions.TransferFile(env.publicProdIp,"./flask/prometheusconfig.yml",env.SSHKEYLOCATION)
                }
            }
        }

        stage('Pull + Run from dockerhub to test server') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    dockerfunctions.PullDockerCompose(env.publicTestIp,env.SSHKEYLOCATION)
                    dockerfunctions.StartDockerCompose(env.publicTestIp,env.SSHKEYLOCATION)
                }
            }
        }

        stage('Curl Test') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    testingfunctions.curlTest(env.publicTestIp,"5000")
                }
            }
        }
        
        stage('Closing test server- if success') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    dockerfunctions.StopDockerCompose(env.publicTestIp,env.SSHKEYLOCATION)
                    dockerfunctions.cleanDockerContainers(env.publicTestIp,env.SSHKEYLOCATION)
                    awsfunctions.closeInstance(env.instanceTestId)
                }
            }
        }


        
        stage('Deployment') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    dockerfunctions.PullDockerCompose(env.publicProdIp,env.SSHKEYLOCATION)
                    dockerfunctions.StartDockerCompose(env.publicProdIp,env.SSHKEYLOCATION)
                    dockerfunctions.cleanDockerContainers(env.publicProdIp,env.SSHKEYLOCATION)
                }
            }
        }
    }
}
