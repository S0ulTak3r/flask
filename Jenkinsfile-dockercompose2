@Library('PipelineFunctions') _

pipeline 
{
    agent any

    environment 
    {
        SSHKEYLOCATION = "/var/lib/jenkins/.ssh/Daniel.pem"
        DOCKERPROJECTNAME = "s0ultak3r/dockerflask"
        DOCKERDBNAME= "s0ultak3r/dockerdb"
        ANSIBLEFOLDER= "/var/lib/jenkins/AnsibleFiles"
        GITURL= "git@github.com:S0ulTak3r/flask.git"
        REQLOCATION= "./flask/flask-app/requirements.txt"
    }

    triggers 
    {
        pollSCM('*/1 * * * *')
    }
    
    stages 
    {
        
        stage('Changes Check') 
        {
            steps 
            {
                script 
                {
                    pipelineFunctions.checkChanges()
                }
            }
        }

        stage('Cleanup') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    try
                    {
                        echo "attempting Cleanup"
                        sh 'rm -rf *'
                        sh "docker images | grep -w 's0ultak3r/dockerflask' | grep -w 1\\.[0-9]* | awk '{print \$2}' | xargs -I {} docker rmi s0ultak3r/dockerflask:{}"
                        sh "docker images | grep -w 's0ultak3r/dockerdb' | grep -w 1\\.[0-9]* | awk '{print \$2}' | xargs -I {} docker rmi s0ultak3r/dockerdb:{}"
                    }
                    catch (Exception e)
                    {
                        echo "Error: ${e.getMessage()}"
                        currentBuild.result = 'FAILURE'
                        error "Failed to cleanup"
                    }
                }

            }
        }
        
        stage('Clone') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    GitFunctions.clonegit(env.GITURL)
                }
            }
        }
        
        stage('Install Dependencies') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    AnsibleFunctions.installDependenciesSystemLvl()
                }
            }
        }

        stage('Build-create docker image and push') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    DockerFunctions.BuildAndPush(env.DOCKERPROJECTNAME, "./flask/flask-app/")
                }
            }
        }
        
        stage('Build-create docker image and pushaaaa') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    DockerFunctions.BuildAndPush(env.DOCKERDBNAME, "./flask/mysql/")
                }
            }
        }

        stage('Get Test+Prod Instance Details + install docker')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                //pulls IP of test instance by automatical means
                script 
                {
                    AwsFunctions.GetInstanceDetails()
                }
            }
        }

        stage("install test+prod docker")
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    AnsibleFunctions.installDockerRemote(env.ANSIBLEFOLDER,"InstallAllComponents.yml")
                }
            }
        }

        stage('fetch docker-compose file to test+prod')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    ScpFunctions.TransferFile(env.publicTestIp,"./flask/docker-compose.yml",env.SSHKEYLOCATION)
                    ScpFunctions.TransferFile(env.publicProdIp,"./flask/docker-compose.yml",env.SSHKEYLOCATION)
                }
            }
        }

        stage('Pull + Run from dockerhub to test server') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    DockerFunctions.PullDockerCompose(env.publicTestIp,env.SSHKEYLOCATION)
                    DockerFunctions.StartDockerCompose(env.publicTestIp,env.SSHKEYLOCATION)
                }
            }
        }

        stage('Curl Test') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                sh "curl http://${env.publicTestIp}:5000"
            }
        }
        
        stage('Closing test server- if success') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    DockerFunctions.StopDockerCompose(env.publicTestIp,env.SSHKEYLOCATION)
                    DockerFunctions.cleanDockerContainers(env.publicTestIp,env.SSHKEYLOCATION)
                    AwsFunctions.closeInstance(env.instanceTestId,env.publicTestIp,env.SSHKEYLOCATION)
                }
            }
        }


        
        stage('Deployment') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    DockerFunctions.PullDockerCompose(env.publicProdIp,env.SSHKEYLOCATION)
                    DockerFunctions.StartDockerCompose(env.publicProdIp,env.SSHKEYLOCATION)
                    DockerFunctions.cleanDockerContainers(env.publicProdIp,env.SSHKEYLOCATION)
                }
            }
        }
    }
}
