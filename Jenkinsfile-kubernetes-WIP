@Library('FunctionsLibrary') _

pipeline
{
    agent any

    environment 
    {
        SSHKEYLOCATION = "/var/lib/jenkins/.ssh/Daniel.pem"
        DOCKERPROJECTNAME = "s0ultak3r/dockerflask"
        DOCKERDBNAME = "s0ultak3r/dockerdb"
        ANSIBLEFOLDER = "/var/lib/jenkins/AnsibleFiles/Daniel-B-AutoAnsible"
        GITURL = "git@github.com:S0ulTak3r/flask.git"
        REQLOCATION = "./flask/flask-app/requirements.txt"
        GIT_SSH_COMMAND = "ssh -o StrictHostKeyChecking=no"
        WINDOWSIP="192.168.56.1"

    }

    triggers 
    {
        pollSCM('*/1 * * * *')
    }

    stages 
    {





        stage('start proxy')
        {
            steps
            {
                script
                {
                    k8functions.startProxyRemote(env.WINDOWSIP)
                }
            }
        }

        stage('Changes Check') 
        {
            steps {
                script 
                {
                    echo "checking "
                    pipelinefunctions.checkChanges()
                }
            }
        }

        stage('Cleanup') {
            when {
                expression {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {

                    echo "attempting Workspace Cleanup"
                    pipelinefunctions.cleanupWorkspace()
                    echo "attempting Docker Cleanup"
                    dockerfunctions.deleteImageVersion("s0ultak3r/dockerflask")
                    dockerfunctions.deleteImageVersion("s0ultak3r/dockerdb")
                }
            }
        }

        stage('Clone') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    gitfunctions.clonegit(env.GITURL)
                }
            }
        }

        stage('Install Dependencies') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    ansiblefunctions.installDependenciesSystemLvl(env.ANSIBLEFOLDER,"installLocal.yml")
                }
            }
        }

        stage('Prepare GKE Cluster') 
        {
            steps 
            {
                script 
                {
                    // Change the current working directory to where your Terraform files are
                    dir('./flask/TerraformFiles') 
                    {
                        // Initialize Terraform
                        sh 'terraform init'

                        // Assume cluster does not exist by default
                        def clusterExists = false

                        // Check if the GKE cluster exists
                        try {
                            def clusterStatus = sh(script: "gcloud container clusters describe cluster-flask --region europe-north1 --format='get(status)'", returnStdout: true).trim()
                            // If the command didn't throw an error, then the cluster exists
                            clusterExists = true
                        } catch(Exception e) {
                            echo 'GKE cluster does not exist. Creating now...'
                        }
                        
                        // If the cluster does not exist or it's not running, apply the Terraform configuration
                        if (!clusterExists) 
                        {
                            sh 'terraform apply -auto-approve'
                        } 
                        else 
                        {
                            echo 'GKE cluster already exists and running. Proceeding...'
                        }

                        // Update the kubectl context
                        echo 'Updating kubectl context...'
                        sh 'gcloud container clusters get-credentials cluster-flask --region europe-north1 --project my-gcp-project'
                    }
                }
            }
        }


        stage('Docker Login')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    dockerfunctions.loginDockerHub()
                }
            }
        }

        stage('Build-create dockerFlask image and push') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    dockerfunctions.BuildAndPush(env.DOCKERPROJECTNAME, "./flask/flask-app/")
                }
            }
        }

        stage('Build-create dockerDB image and push') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    dockerfunctions.BuildAndPush(env.DOCKERDBNAME, "./flask/mysql/")
                }
            }
        }



        stage('Deployment To Testing Enviornment') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    echo 'Making Sure I am in the right context...'
                    k8functions.changeContext("docker-desktop")

                    echo "Deploying application"
                    k8functions.applyWithFile("./flask/KubernetesFiles/deployment.yml")
                    k8functions.applyWithFile("./flask/KubernetesFiles/service.yml")

                    echo "pulling tcp port"
                    def tcpport=sh(script: "kubectl get service flask-service -o=jsonpath='{.spec.ports[*].nodePort}'", returnStdout: true).trim()
                    env.KUBECTLTCPPORT = tcpport
                }

            }
        }



        stage('Rollout Restart') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    k8functions.rollout("deployment/flask-deployment")
                    k8functions.rollout("deployment/mysql-deployment")
                }
            }
        }

        stage('Testing Test Enviornment')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    testingfunctions.curlTest(env.WINDOWSIP,env.KUBECTLTCPPORT)
                }
            }
        }

        stage('Closing Testing Environment')
        {
            when
            {
                expression
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    echo "closing test environment..."
                    k8functions.deleteWithFile("./flask/KubernetesFiles/deployment.yml")
                    k8functions.deleteWithFile("./flask/KubernetesFiles/service.yml")
                }
            }
        }


        stage('Deploying On Google Kubernetes Production')
        {
            when
            {
                expression
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    echo "deploying on google kubernetes production..."
                    k8functions.changeContext("gke_vernal-tracer-393305_europe-north1_cluster-flask")
                    k8functions.applyWithFile("./flask/KubernetesFiles/deployment.yml")
                    k8functions.applyWithFile("./flask/KubernetesFiles/servicedeployment.yml")
                }
            }
        }


        stage('Rollout Restart Production') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    echo 'Performing rollout restart...'
                    k8functions.rollout("deployment/flask-deployment")
                    k8functions.rollout("deployment/mysql-deployment")
                    k8functions.getAllInfo()
                }
            }
        }

        stage('closing proxy')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    k8functions.closeProxyRemote(env.WINDOWSIP)
                }
            }
        }


    }
}
