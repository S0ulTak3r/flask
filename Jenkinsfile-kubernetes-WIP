@Library('FunctionsLibrary') _

pipeline
{
    agent any

    environment 
    {
        SSHKEYLOCATION = "/var/lib/jenkins/.ssh/Daniel.pem"
        DOCKERPROJECTNAME = "s0ultak3r/dockerflask"
        DOCKERDBNAME = "s0ultak3r/dockerdb"
        ANSIBLEFOLDER = "/var/lib/jenkins/AnsibleFiles/Daniel-B-AutoAnsible"
        GITURL = "git@github.com:S0ulTak3r/flask.git"
        REQLOCATION = "./flask/flask-app/requirements.txt"
        GIT_SSH_COMMAND = "ssh -o StrictHostKeyChecking=no"
        WINDOWSIP="192.168.56.1"

    }

    triggers 
    {
        pollSCM('*/1 * * * *')
    }

    stages 
    {





        stage('start proxy')
        {
            steps
            {
                script
                {
                    k8functions.startProxyRemote(env.WINDOWSIP)
                }
            }
        }

        stage('Changes Check') 
        {
            steps {
                script 
                {
                    echo "checking "
                    pipelinefunctions.checkChanges()
                }
            }
        }

        stage('Cleanup') {
            when {
                expression {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {

                    echo "attempting Workspace Cleanup"
                    pipelinefunctions.cleanupWorkspace()
                    echo "attempting Docker Cleanup"
                    dockerfunctions.deleteImageVersion("s0ultak3r/dockerflask")
                    dockerfunctions.deleteImageVersion("s0ultak3r/dockerdb")
                }
            }
        }

        stage('Build (Git Clone, Helm Package)') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    gitfunctions.clonegit(env.GITURL)
                    helmfunctions.packageHelmChart("./flask", "my-terraform-state-bucket-flaskproject", "helm-packages")
                }
            }
        }


        stage('Install Dependencies') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    ansiblefunctions.installDependenciesSystemLvl(env.ANSIBLEFOLDER,"installLocal.yml")
                }
            }
        }

        stage('Prepare GKE Cluster') 
        {
            steps 
            {
                script 
                {
                    // Change the current working directory to where your Terraform files are
                    dir('./flask/TerraformFiles') 
                    {
                        // Initialize Terraform
                        sh 'terraform init'

                        // Assume cluster does not exist by default
                        def clusterExists = false

                        // Check if the GKE cluster exists
                        try {
                            def clusterStatus = sh(script: "gcloud container clusters describe cluster-flask2 --region me-west1 --format='get(status)'", returnStdout: true).trim()
                            // If the command didn't throw an error, then the cluster exists
                            clusterExists = true
                        } catch(Exception e) {
                            echo 'GKE cluster does not exist. Creating now...'
                        }
                        
                        // If the cluster does not exist or it's not running, apply the Terraform configuration
                        if (!clusterExists) 
                        {
                            sh 'terraform apply -auto-approve'
                        } 
                        else 
                        {
                            echo 'GKE cluster already exists and running. Proceeding...'
                        }

                        // Update the kubectl context
                        echo 'Updating kubectl context...'
                        sh 'gcloud container clusters get-credentials cluster-flask2 --zone me-west1-a --project vernal-tracer-393305'
                    }
                }
            }
        }


        stage('Docker Login')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    dockerfunctions.loginDockerHub()
                }
            }
        }

        stage('Build-create dockerFlask image and push') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    dockerfunctions.BuildAndPush(env.DOCKERPROJECTNAME, "./flask/flask-app/")
                }
            }
        }

        stage('Build-create dockerDB image and push') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script 
                {
                    dockerfunctions.BuildAndPush(env.DOCKERDBNAME, "./flask/mysql/")
                }
            }
        }



        stage('Deployment To Testing Enviornment') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    echo 'Making Sure I am in the right context...'
                    k8functions.changeContext("docker-desktop")

                    echo "Deploying application using Helm"
                    def releaseName = "flask-release"
                    
                    // Get the latest version of the packaged chart
                    def latestChart = sh("ls ./flask/myproject*.tgz | sort -V | tail -n 1", returnStdout: true).trim()

                    
                    sh "helm upgrade --install ${releaseName} ${latestChart}"

                    echo "pulling tcp port"
                    def tcpport = sh("kubectl get service flask-service-testing -o=jsonpath='{.spec.ports[*].nodePort}'", returnStdout: true).trim()
                    env.KUBECTLTCPPORT = tcpport
                }
            }
        }





        stage('Rollout Restart') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    k8functions.rollout("deployment/flask-deployment")
                    k8functions.rollout("deployment/mysql-deployment")
                }
            }
        }

        stage('Testing Test Enviornment')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    testingfunctions.curlTest(env.WINDOWSIP,env.KUBECTLTCPPORT)
                }
            }
        }

        stage('Closing Testing Environment')
        {
            when
            {
                expression
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    echo "closing test environment..."
                    k8functions.uninstallHelmRelease("flask-release")
                }
            }
        }



        stage('Deploying On Google Kubernetes Production') 
        {
            when {
                expression {
                    return env.NO_CHANGES != "true"
                }
            }
            steps {
                script {
                    echo "Deploying on Google Kubernetes production..."
                    k8functions.changeContext("gke_vernal-tracer-393305_me-west1-a_cluster-flask2")
                    
                    // Extract the name of the latest Helm package from the current directory
                    def chartPackagePath = sh(script: "ls ./flask/myproject*.tgz | sort -V | tail -n 1", returnStdout: true).trim()

                    // Check if Helm release exists
                    def releaseName = "flask-prod"
                    def releaseExists = sh(script: "helm list -q | grep ${releaseName}", returnStatus: true)

                    if (releaseExists == 0) {
                        // Helm release exists, upgrade it
                        sh "helm upgrade ${releaseName} ${chartPackagePath}"
                    } else {
                        // Helm release doesn't exist, install it
                        sh "helm install ${releaseName} ${chartPackagePath}"
                    }
                }
            }
        }





        stage('Rollout Restart Production') 
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps 
            {
                script
                {
                    echo 'Performing rollout restart...'
                    k8functions.rollout("deployment/flask-deployment")
                    k8functions.rollout("deployment/mysql-deployment")
                    k8functions.getAllInfo()
                }
            }
        }

        stage('closing proxy')
        {
            when 
            {
                expression 
                {
                    return env.NO_CHANGES != "true"
                }
            }
            steps
            {
                script
                {
                    k8functions.closeProxyRemote(env.WINDOWSIP)
                }
            }
        }


    }
}
